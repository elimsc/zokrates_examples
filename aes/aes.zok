import "utils/casts/u8_to_field" as u8_to_field
import "EMBED/u8_from_bits" as u8_from_bits
import "utils/pack/bool/unpack128" as unpack128

def sub_bytes(u8[4][4] s) -> u8[4][4]:
    u8[256] s_box = [
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    ]

    for field i in 0..4 do
        for field j in 0..4 do
            s[i][j] = s_box[u8_to_field(s[i][j])]
        endfor
    endfor
    return s


def shift_rows(u8[4][4] s) -> u8[4][4]:
    u8[4][4] s1 = s
    
    s[0][1] = s1[1][1]
    s[1][1] = s1[2][1]
    s[2][1] = s1[3][1]
    s[3][1] = s1[0][1]

    s[0][2] = s1[2][2]
    s[1][2] = s1[3][2]
    s[2][2] = s1[0][2]
    s[3][2] = s1[1][2]

    s[0][3] = s1[3][3]
    s[1][3] = s1[0][3]
    s[2][3] = s1[1][3]
    s[3][3] = s1[2][3]

    return s


def add_round_key(u8[4][4] s, u8[4][4] k) -> u8[4][4]:
    for field i in 0..4 do
        for field j in 0..4 do
            s[i][j] = s[i][j] ^ k[i][j]
        endfor
    endfor
    return s


def xtime(u8 a) -> u8:
    u8 v = if (a & 0x80 != 0x00) then ((a << 1) ^ 0x1B) & 0xFF else a << 1 fi
    return v


def mix_columns(u8[4][4] s) -> u8[4][4]:
    for field i in 0..4 do
        u8[4] a = s[i]

        // mix_single_column
        u8 t = a[0] ^ a[1] ^ a[2] ^ a[3]
        u8 u = a[0]
        a[0] = a[0] ^ t ^ xtime(a[0] ^ a[1])
        a[1] = a[1] ^ t ^ xtime(a[1] ^ a[2])
        a[2] = a[2] ^ t ^ xtime(a[2] ^ a[3])
        a[3] = a[3] ^ t ^ xtime(a[3] ^ u)

        s[i] = [...a]
    endfor
    return s

def bytes2matrix(u8[16] text) -> u8[4][4]:
    u8[4][4] m = [[0x00;4], [0x00;4], [0x00;4], [0x00;4]]
    for field i in 0..4 do
        for field j in 0..4 do
            m[i][j] = text[i*4+j] 
        endfor
    endfor
    return m


def matrix2bytes(u8[4][4] matrix) -> u8[16]:
    u8[16] text = [0x00;16]
    for field i in 0..4 do
        for field j in 0..4 do
            text[i*4+j] = matrix[i][j]
        endfor
    endfor
    return text


def xor4(u8[4] a, u8[4] b) -> u8[4]:
    u8[4] v = [0x00;4]
    for field i in 0..4 do
        v[i] = a[i] ^ b[i]
    endfor
    return v


def xor16(u8[16] a, u8[16] b) -> u8[16]:
    u8[16] v = [0x00;16]
    for field i in 0..16 do
        v[i] = a[i] ^ b[i]
    endfor
    return v


def split_blocks(u8[32] message) -> u8[2][16]:
    // field block_size = 16
    u8[2][16] l = [[0x00;16],[0x00;16]]
    for field i in 0..2 do
        for field j in 0..16 do
            l[i][j] = message[i*16+j]
        endfor
    endfor
    return l


def helper_in_expand_key(u8[4] word, field i) -> u8[4]:
    u8[32] r_con = [
        0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
        0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
        0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,
        0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39
    ]
    u8[256] s_box = [
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    ]

    u8 temp = word[0]
    word[0] = word[1]
    word[1] = word[2]
    word[2] = word[3]
    word[3] = temp
    // Map to S-BOX.
    for field j in 0..4 do
        word[j] = s_box[u8_to_field(word[j])]
    endfor
    // XOR with first byte of R-CON, since the others bytes of R-CON are 0.
    word[0] = word[0] ^ r_con[i]
    return word

def expand_key(u8[16] master_key) -> u8[11][4][4]:
    field n_rounds = 10
    
    u8[4][4] key_columns = bytes2matrix(master_key)
    field iteration_size = 4

    // Each iteration has exactly as many columns as the key material.
    field i = 1
    // field len_key_columns = 4
    u8[44][4] var_key_colums = [[0x00;4];44]
    var_key_colums[0] = key_columns[0]
    var_key_colums[1] = key_columns[1]
    var_key_colums[2] = key_columns[2]
    var_key_colums[3] = key_columns[3]

    for field len_key_columns in 4..(n_rounds+1)*4 do
        // Copy previous word.
        u8[4] word = var_key_colums[len_key_columns-1]

        // Perform schedule_core once every "row". len_key_columns % 4 == 0
        word = if ( len_key_columns == 4 || len_key_columns == 8 || len_key_columns == 12 || len_key_columns == 16 || len_key_columns == 20  || len_key_columns == 24 || len_key_columns == 28 || len_key_columns == 32 || len_key_columns == 36 || len_key_columns == 40 || len_key_columns == 44) then helper_in_expand_key(word, i) else word fi
        i = if ( len_key_columns == 4 || len_key_columns == 8 || len_key_columns == 12 || len_key_columns == 16 || len_key_columns == 20  || len_key_columns == 24 || len_key_columns == 28 || len_key_columns == 32 || len_key_columns == 36 || len_key_columns == 40 || len_key_columns == 44) then i + 1 else i fi

        // XOR with equivalent word from previous iteration.
        word = xor4(word, var_key_colums[len_key_columns-iteration_size])
        var_key_colums[len_key_columns] = word
    endfor

    u8[11][4][4] m = [[[0x00;4];4];11]
    for field j in 0..11 do
        for field k in 0..4 do
            m[j][k] = var_key_colums[j*4+k]
        endfor
    endfor
    return m


def encrypt_block(u8[16] plaintext, u8[11][4][4] key_matrices) -> u8[16]:

    u8[4][4] plain_state = bytes2matrix(plaintext)
    field n_rounds = 10 // AES-128

    plain_state = add_round_key(plain_state, key_matrices[0]) 

    for field i in 1..n_rounds do
        plain_state = sub_bytes(plain_state)
        plain_state = shift_rows(plain_state)
        plain_state = mix_columns(plain_state)
        plain_state = add_round_key(plain_state, key_matrices[i])
    endfor

    plain_state = sub_bytes(plain_state)
    plain_state = shift_rows(plain_state)
    plain_state = add_round_key(plain_state, key_matrices[10])

    return matrix2bytes(plain_state)

def field_to_u8_16(field a) -> u8[16]:
    bool[128] bits = unpack128(a)
    return [u8_from_bits(bits[0..8]), u8_from_bits(bits[8..16]), u8_from_bits(bits[16..24]), u8_from_bits(bits[24..32]), u8_from_bits(bits[32..40]), u8_from_bits(bits[40..48]), u8_from_bits(bits[48..56]), u8_from_bits(bits[56..64]), u8_from_bits(bits[64..72]), u8_from_bits(bits[72..80]), u8_from_bits(bits[80..88]), u8_from_bits(bits[88..96]), u8_from_bits(bits[96..104]), u8_from_bits(bits[104..112]), u8_from_bits(bits[112..120]), u8_from_bits(bits[120..128])]


def main(private field plaintext1, private field master_key1, field iv1, field provided_cipher1) -> bool:
    // field to u8[16]
    u8[16] plaintext = field_to_u8_16(plaintext1)
    u8[16] master_key = field_to_u8_16(master_key1)
    u8[16] iv = field_to_u8_16(iv1)
    u8[16] provided_cipher = field_to_u8_16(provided_cipher1)

    u8[11][4][4] key_matrices = expand_key(master_key) // key expand
    u8[16] cipher = encrypt_block(xor16(plaintext, iv), key_matrices)
    bool r = true
    for field i in 0..16 do
        r = r && (cipher[i] == provided_cipher[i])
    endfor
    return r 


// 173928 -- without key expand
// 339906 -- with key expand

